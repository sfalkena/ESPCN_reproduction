{
  
    
        "post0": {
            "title": "Learning To Efficiently See In The Dark",
            "content": "By Sieger Falkena, Anwesh Marwade and Joris Quist . With the ever growing amount of papers published, the field of Computer Vision by Deep Learning is more relevant than ever. Many new solutions are presented every day. Models get bigger and more complex. Together with computer vision, the market of smart-phone and smart-wearables is growing. Estimates have been made that in 2020, around 1.4 trillion photo&#39;s will be made worldwide from which 90.9% will originate from smartphones [4]. . However, the differences in computing power between the two sectors is enormous. Deep learning models require powerfull GPU&#39;s to train and evaluate a model. Smartphones don&#39;t offer this. To accomodate that the two sectors are growing towards each other, two paths are being followed: smartphones are equipped with more powerfull hardware every year making that smartphones can offer more services. On the other hand, deep learning models are made more and more efficient, so that evaluation can be done on a wearable device. . In this article, we want to take a step towards the direction of efficient neural networks. We will combine methods from different active fields of study and present an efficient method to process low-light images. We showcase the implementation details of applying the concept of network binarization using &quot;Accurate Binary Convolutional Network&quot; (ABC-Net) in &quot;Learning To See In The Dark&quot; (LSID) [1] paradigm. In doing so, we want to find out whether the full accuracy network can be approximated by binarization. We aim for limited performance loss as compared to the full precision model while driving up the efficiency. We intend to highlight the theoretical speedup that can be achieved and shed light on the limitations that we faced. . Click https://sfalkena.github.io/blogs/_pages/interactive_image.html or scan the QR code below to see an interactive comparison of the results in high resolution! Warning: the images are in high resolution, so the loading of images might be slow ;) . . Techniques used . First, let us introduce the problem that we propose to tackle. This problem is presented by Chen et. al in &quot;Learning to see in the dark&quot; [1], where the authors take a raw image file (short-exposure images which are grainy and suffer from noise due to low-lighting and high ISO values) and use a deep neural network to learn the image-processing pipeline to process the low-light raw data. By working directly with raw sensor data, the authors intend to replace the standard imaging pipeline. Intending to achieve this, the authors train a convolutional network with a new dataset involving raw short-exposure low-light images with corresponding long-exposure images as the target reference or ground truth. . The pipeline suggested by the authors can be seen in the figure below. First, the raw image is unpacked, the black levels are subtracted after which the image is amplified. Finally, the image is fed through the CNN, and the output is an RGB image. . . For examples of the results achieved by in the paper, look at https://cchen156.github.io/SID.html for an interactive comparison. . To make the ConvNet in the figure shown above more efficient, binarization is applied to the ConvNet. For this, we follow the fundamental techniques of binary convolution using XNOR and bitcount operations by Rastegari et al. in &quot;XNOR-Net&quot; [5]. In applying binarization, we explore two schemes for implementing a binary network namely, XNOR-Net and ABC-Net. In the following section, we first explain the XNOR-Net, after which we dive into the ABC-Net implementation in detail. . For the interested reader, we have written a chapter where we explain the basics of Binary Networks in more detail. For the rest of the paper, we assume that the reader has knowledge of this chapter and knows the fundamentals of binarization. . XNOR-Net . The first binarization technique that we explored is the XNOR-Net implementation presented in [5]. In XNOR-Networks, both the filters and the input to the convolutional layers are binarized which allows these networks to approximate the convolutions primarily using binary operations. The efficiency and speedup can be achieved by leveraging the XNOR and bit-counting operations to estimate the convolutions. . We replace the LSID layers with the binarized convolutions which are mentioned in detail in the ABC-Net section. Reading further into the implementation we realised that ABC-Net is a generalisation of the XNOR-Net. Being a generalisation, the ABC-net extends better representational power by approximating the convolutions using multiple binarized weights and activations, but still has the option to evaluate the performance of the XNOR-Net when using only a single bit for both weights and activations. . ABC-Net . We implemented this by using the follow-up work shown by Lin et al. [2] to achieve higher accuracy than XNOR-Net. Lin et al. developed a new type of convolutional network called the Accurate Binary Convolutional Network or ABC-Net. Explained very briefly, ABC-Net approximates the full precision convolution using $M cdot N$ binary convolutions from XNOR-Nets, where $M$ is the number of bits used to approximate the weights and $N$ the number of bits to approximate the activations. . Again, in our chapter, ABC-Net is explained in more detail. However, we intend to provide some intuition regarding the ABC-Net as mentioned below. . . The ABC-Net approximates each real-valued by using multiple binary values per weight, giving it better representational power. The approximation is achieved as follows: begin{equation} W approx alpha_1 mathbf{B}_1 + alpha_2 mathbf{B}_2 + ... + alpha_M mathbf{B}_M end{equation} . Finding a good value for $ mathbf{B}_i$ and $ alpha_i$ comes down to the following optimization problem: . begin{equation} min limits_{ mathbf{ alpha}, mathbf{B}}J( mathbf{ alpha}, mathbf{B}) = || mathbf{w} - mathbf{B} mathbf{ alpha}||^2, ; ; ; ; s.t. : mathbf{B}_{ij} in {-1,+1 } end{equation}Where $ mathbf{B} = [vec( mathbf{B}_1), vec( mathbf{B}_2), ..., vec( mathbf{B}_M)]$, $ mathbf{w} = vec( mathbf{W})$ and $ mathbf{ alpha} = [ alpha_1, alpha_2, ..., alpha_M]^T$. Trying to find the optimum to this problem numerically, makes it quite difficult as it is no longer possible to compute the derivative w.r.t. $ textbf{W}$ using the Straight-Through-Estimator [add reference]. Therefore the optimum is approximated by first calculating each $B_i$ in the following way: . begin{equation} mathbf{B}_i = sign( overline{ textbf{W}} + u_istd( mathbf{W})), i = 1,2,...,M end{equation}Where $ overline{ textbf{W}} = textbf{W} - mean( textbf{W})$ and $u_i$ is picked evenly over the the range $[-std( mathbf{W}), std( mathbf{W})]$. This is done because experimental observations show that real-valued weights often look like they are drawn from a Gaussian distribution. . Importantly, to be able to take full advantage of the more efficient XNOR and bitcount operations for the convolutions, the activations need to be binarized in addition to the network weights. The ABC-Net does this by using multiple bits per activation to get a better approximation of the original i.e. full precision activations. However, it is not desirable to use the same method for binarizing the activations as we do for the weights, because the alpha values (and the beta values for the activations) need to be calculated using linear regression. For the weights, this is not a big problem, since this only needs to happen when they need to be updated, which only happens during training. It thus has no impact on the inference speed. However, this is not the case for the activations since these always vary at test time. . The way they implemented this, was by first using batch normalization, so that the mean and standard deviation of the activation didn&#39;t need to be calculated, but could be assumed to be $0$ and $1$. They then replaced the linear regression that was used to calculate alpha by a learnable parameter beta. This way the there is no need anymore to do linear regression or calculate the mean and standard deviation during inference. . Theoretical speedup . Before we dive into the speedup that would theoretically be possible, we need to understand more about the factors that influence this speedup. The speedup is achieved by binarizing the weights and activations of the convolution. For binarizing the weights, the full precision weights are approximated with $ boldsymbol{W} approx alpha_{1} boldsymbol{B}_{1}+ alpha_{2} boldsymbol{B}_{2}+ cdots+ alpha_{M} boldsymbol{B}_{M}$. So $M$ BinConvs are used as can be seen on the left part of the figure above. Furthermore, the activations $R$ can also be binarized by approximating $ boldsymbol{R} approx beta_{1} A_{1}+ beta_{2} A_{2}+ cdots+ beta_{N} boldsymbol{A}_{N}$. . According to [5] the speedup of using XNOR-Net is the ratio of the operations carried out by a normal convolution and the binarized XNOR convolution: $S= frac{64 c N_{W}}{c N_{W} + 64}$, where $N_{ mathbf{W}}=w h$ (the number of entries in the weights) and $c$ is the number of channels. For justification of this equation, please refer to the original paper. The alert reader will notice that the speedup does not depend on the size of the input. . Because there are now $N times M$ of these BinConvs, the speedup per convolutional layer linearly decreases with this number and becomes $S= frac{64 c N_{W}}{M N (c N_{W} + 64)}$. To draw conclusions about the total speedup of the network, we have to look into the architecture and take the sum of all operations done over all layers when not using BinConvs and dividing this by the amount operations that are needed when BinConvs are being used. This will then give the theoretical speedup of the entire network. In the results section, this number will be shown for all the different networks used in the experiments. . Even when not binarizing the activations, still some speedup could be achieved. This is because when using binary weights there is no need to do multiplication and addition of the activation with weight anymore, it can be immediately added or subtracted. The speedup of this can be roughly estimated to be 2, since only half of the operations need to be done (ignoring overhead like adding the bias). The speedup is then given by $S approx frac{2}{M N}$, since again the speedup linearly decreases with the amount of times the BinConv is used. Note here that when using a value larger than $1$ for either $M$ or $N$, all speedup is immediately lost. However, there is at that point still the possibility of reduced memory usage. . Technical constraints . In the introduction, as an alert reader must have noticed, we stress that we are aiming for limiting the performance loss rather than only aiming for increase in efficiency. The reason for this is the fact that binarization is still a fairly new field of study. To convert the theoretical speedup of the network into practice, special hardware or software needs to be used. The speedup is realized by using XNOR and bitcount operations [1]. Intel researchers in [6] have compared running a binarized network on different architectures, and they have pointed out that specialised hardware like FPGAs have a greater potential for running binarized networks. For now, the platform that we use i.e. PyTorch does not offer possibilities to achieve and leverage this practical speedup to which end we feel that it is currently out of the scope of this project. . Implementation of the code . In this section, certain relevant parts of the code will be highlighted. . Architecture . Below, the architecture of the binarized LTSITD (ABCLSID) is shown. Some remarks about the architecture: . The first and last layer are not binarized and uses normal convolution. The speedup of binarizing is smaller here because of the low amount of channels or small kernel size. | Rest of the architectural decisions (channels, kernel size, etc.) are kept the same i.e. as per the original LTSITD implementation. The layer order from LTSITD adhered according to the layer order recommended by [5]. | . class ABCLSID(nn.Module): def __init__(self, inchannel=4, block_size=2, M=3, N=None, binary_transposed_conv=True): super(ABCLSID, self).__init__() self.M = M self.N = N self.binary_transposed_conv = binary_transposed_conv self.block_size = block_size self.conv1_1 = nn.Conv2d(inchannel, 32, kernel_size=3, stride=1, padding=1, bias=True, ) self.lrelu = nn.LeakyReLU(negative_slope=0.2, inplace=True) self.conv1_2 = ABCConv2d(32, 32, kernel_size=3, stride=1, padding=1, bias=True, M=M) self.maxpool = nn.MaxPool2d(kernel_size=2, stride=2, padding=0, ceil_mode=True) self.conv2_1 = ABCConv2d(32, 64, kernel_size=3, stride=1, padding=1, bias=True, M=M) self.conv2_2 = ABCConv2d(64, 64, kernel_size=3, stride=1, padding=1, bias=True, M=M) self.conv3_1 = ABCConv2d(64, 128, kernel_size=3, stride=1, padding=1, bias=True, M=M) self.conv3_2 = ABCConv2d(128, 128, kernel_size=3, stride=1, padding=1, bias=True, M=M) self.conv4_1 = ABCConv2d(128, 256, kernel_size=3, stride=1, padding=1, bias=True, M=M) self.conv4_2 = ABCConv2d(256, 256, kernel_size=3, stride=1, padding=1, bias=True, M=M) self.conv5_1 = ABCConv2d(256, 512, kernel_size=3, stride=1, padding=1, bias=True, M=M) self.conv5_2 = ABCConv2d(512, 512, kernel_size=3, stride=1, padding=1, bias=True, M=M) if self.binary_transposed_conv: self.up6 = ABCConvTranspose2d(512, 256, 2, stride=2, bias=False, M=M) else: self.up6 = nn.ConvTranspose2d(512, 256, 2, stride=2, bias=False) self.conv6_1 = ABCConv2d(512, 256, kernel_size=3, stride=1, padding=1, bias=True, M=M) self.conv6_2 = ABCConv2d(256, 256, kernel_size=3, stride=1, padding=1, bias=True, M=M) if self.binary_transposed_conv: self.up7 = ABCConvTranspose2d(256, 128, 2, stride=2, bias=False, M=M) else: self.up7 = nn.ConvTranspose2d(256, 128, 2, stride=2, bias=False) self.conv7_1 = ABCConv2d(256, 128, kernel_size=3, stride=1, padding=1, bias=True, M=M) self.conv7_2 = ABCConv2d(128, 128, kernel_size=3, stride=1, padding=1, bias=True, M=M) if self.binary_transposed_conv: self.up8 = ABCConvTranspose2d(128, 64, 2, stride=2, bias=False, M=M) else: self.up8 = nn.ConvTranspose2d(128, 64, 2, stride=2, bias=False) self.conv8_1 = ABCConv2d(128, 64, kernel_size=3, stride=1, padding=1, bias=True, M=M) self.conv8_2 = ABCConv2d(64, 64, kernel_size=3, stride=1, padding=1, bias=True, M=M) if self.binary_transposed_conv: self.up9 = ABCConvTranspose2d(64, 32, 2, stride=2, bias=False, M=M) else: self.up9 = nn.ConvTranspose2d(64, 32, 2, stride=2, bias=False) self.conv9_1 = ABCConv2d(64, 32, kernel_size=3, stride=1, padding=1, bias=True, M=M) self.conv9_2 = ABCConv2d(32, 32, kernel_size=3, stride=1, padding=1, bias=True, M=M) out_channel = 3 * self.block_size * self.block_size self.conv10 = nn.Conv2d(32, out_channel, kernel_size=1, stride=1, padding=0, bias=True) for m in self.modules(): if isinstance(m, nn.Conv2d): n = m.kernel_size[0] * m.kernel_size[1] * m.out_channels m.weight.data.normal_(0, math.sqrt(2. / n)) m.bias.data.zero_() elif isinstance(m, nn.ConvTranspose2d): n = m.kernel_size[0] * m.kernel_size[1] * m.out_channels m.weight.data.normal_(0, math.sqrt(2. / n)) . Datasets and data processing . In the section &quot;Techniques used&quot;, we already mentioned briefly that the authors of [1] created a new dataset to train and evaluate the model. In this section, we want to explain a bit more about the importance of the dataset. . Let&#39;s start with explaining what kind of data we are we dealing with. The authors have created a dataset with low-light images. The original dataset has been shot with two cameras: A Sony $ alpha$7S II and a Fujifilm X-T2. The reason behind using two different cameras has to do with the different ways in which the images get stored. The Sony uses a Bayer filter, whereas the Fujifilm uses an X-Trans filter. We leave the exploration of the X-Trans filter to the reader as we have chosen to focus solely on the Sony camera for this project endeavour. The reason for this is that Sony is the leading company in the smartphone camera domain and holds 50.1 % of the market share as of 2019. As mentioned above, the Sony images use a Bayer filter. We would suggest reading this blog to develop a better understanding about Bayer filters. The first image of our blog shows the input image being in its Bayer form. The de-mosaicing step in the aforementioned blog is included in the ConvNet pipeline. . So, going back to the dataset, it contains groups of images shot in exactly the same way, but with different exposure times, meaning that we have bright, ground truth images, together with dark, low-exposure images. To test the rigidity of the network, images with exposure times of $0.033s, 0.04s, 0.1s$ have been captured. . The said raw images are of size 4256x2848. However, these images are still in the Bayer form, which means that they need to be unpacked into 2128x1424 sized images with 4 colour channels. Additionally, these images are considerably big to be loaded into memory as a whole. This memory contraint meant that it was not possible to perform backpropagation with the entire image as input, because then our GPU would run out of memory (8 GiB). This, and the fact that the authors of LSID also train using patches, is why we train the network on patches of the images. The patch size used is 512x512 pixels. . Another problem was that, the training was very slow. At first it would have taken around 6 days to train the network. The reason for this was the way the images were loaded and processed. The way it was done, was that in each iteration, an image was loaded from the disk, processing was done (by the python rawpy module) and then a random patch was taken from that image. The bottleneck at that point was the loading of the images from disk to memory. Even with 8 data loading workers that simultaneously loaded images, it wasn&#39;t enough. Furthermore, using more workers caused overheads in other places and hence did not improve performance. The way the authors overcame this problem was by keeping all the data in memory. The problem for us, however, was that the dataset was 64 Gigabytes and we only had 16 Gigabytes of RAM storage. The way we fixed this issue was by preprocessing the data. We first loaded the images, did the processing, but then instead of taking a random patch, we took 15 patches in a grid of 3 by 5. This was the smallest number of patches that together (with a bit of overlap) covered the entire image. We then stored these patches. By performaing the mentioned steps, during training, we could directly load the patch instead of the entire image. This improved our training speed significantly, which meant that we could train the network in just 22 hours which was quite a considerable reduction in time. This method does have some disadvantages, because this way we always use the same set of patches instead of random ones, which could, in theory, affect the result after training. However we still achieve highly comparable results on the test set as the original model. This led us to conclude that it probably did not matter much. Another problem that we dealt with was that the raw images had an 14-bit encoding, which after processing gets converted to 32-bit tensors. Plus, the patches were slightly overlapping. Together this caused our newly processed training set to be 353GB, which is not very practical to store. In the end our epochs were changed from taking a random patch of the 1865 images, to using $15 cdot1865=27975$ fixed patches. . Binary convolution . One problem we encountered during the project was because we did not have access to efficient implementations of the binary convolutions implying that we had to use the standard convolutions for 32-bit Floating-point numbers. This meant that instead of a getting a speedup as mentioned in Section &quot;Theoretical speedup&quot;, it took about $M cdot N$ times longer to do a forward pass, since that is the amount of convolutions we now had to do in each layer. This would mean that training would again take too long. To remedy this, we slightly deviated from the procedure that is described in the ABC-Net paper. We still calculated the binary tensors and their multipliers in the same way, but instead of using them in separate convolutions, we used them to approximate the original weights again. In theory this should give the same results. In practice, both these methods had small differences in their outputs. This is probably due to floating-point errors. These errors, however, were minute enough to not impact a real difference during training or in performance. In the code snippet below, we first have two functions implementing the shift operation as in equation 2 from [2]. . import torch.nn as nn from torch import Tensor import torch def shift_parameter_binarization(tensor, shift_parameters, empty_cache): if empty_cache: # print(&quot;Emptying cache&quot;) torch.cuda.empty_cache() return torch.cat( [((tensor - tensor.mean()) + shift_parameter).sign() for shift_parameter in shift_parameters]) def shift_parameter_binarization_activation(tensor, shift_parameters, empty_cache): if empty_cache: torch.cuda.empty_cache() return torch.cat( [((tensor - tensor.mean()) + shift_parameter).sign() for shift_parameter in shift_parameters]) . Binary 2D convolution . class ABCConv2d(nn.Conv2d): def __init__(self, in_channels, out_channels, kernel_size, M=3, N=None, estimated_weights=True, stride=1, padding=0, dilation=1, groups=1, bias=True, padding_mode=&#39;zeros&#39;): super(ABCConv2d, self).__init__(in_channels, out_channels, kernel_size, stride=stride, padding=padding, dilation=dilation, groups=groups, bias=bias, padding_mode=padding_mode) self.M = M self.N = N if self.N: self.betas = torch.nn.Parameter(Tensor(N)) self.vs = torch.nn.Parameter(Tensor(N)) nn.init.normal_(self.betas) nn.init.normal_(self.vs) self.use_estimated_tensors = estimated_weights # Calculates the alphas based on the binarized and real weights using linear regression def get_alphas(self, B): vectorized_B = B.view(self.M, -1).t() return vectorized_B.t().mm(vectorized_B).inverse().mm(vectorized_B.t()).mv(self.weight.data.view(-1)) # Binarize the weights in M matrices def get_B(self): weights = self.weight.data return shift_parameter_binarization(weights, [(-1 + i * 2 / (self.M - 1)) * weights.std() for i in range(self.M)], empty_cache=(not self.training)) # Binarize the weights in M matrices def get_binary_activation(self, input): binary_input = shift_parameter_binarization_activation(input, [(-1 + i * 2 / (self.N - 1)) * input.std() for i in range(self.N)], empty_cache=(not self.training)) vectorized_binary_input = binary_input.view(self.N, -1).t() betas = vectorized_binary_input.t().mm(vectorized_binary_input).pinverse().mm(vectorized_binary_input.t()).mv( input.view(-1)) estimated_binary_input = torch.mv(vectorized_binary_input, betas) # del binary_input return estimated_binary_input.view(input.shape) def get_estimated_weights(self, B, alpha): vectorized_B = B.view(self.M, -1).t() estimated_weights = torch.mv(vectorized_B, alpha) return estimated_weights.view(self.weight.shape) def forward(self, x: Tensor) -&gt; Tensor: # if self.training or self.B is None or self.alpha is None: B = self.get_B() alphas = self.get_alphas(B) if self.N: x.data = self.get_binary_activation(x) if self.use_estimated_tensors: x = nn.functional.conv2d(x, self.get_estimated_weights(B, alphas), self.bias, self.stride, self.padding, self.dilation, self.groups) else: x = sum(alphas[i] * nn.functional.conv2d(x, B[i], stride=self.stride, padding=self.padding, dilation=self.dilation, groups=self.groups) for i in range(self.M)) if self.bias: x += self.bias[None, ..., None, None].repeat(1, 1, x.shape[2], x.shape[3]) return x . Binary 2D transposed convolution . For the transposed convolution, we have not yet seen any implementation online, so we have estimated that it can be done in a similar way as the normal binary 2D convolution. . Initialization . A very useful aspect of ABC-Net is the fact that it uses multiple bits to approximate the original real-valued weights. This means that if you have a trained model and you want to replace the normal convolutions with the approximated convolutions of ABC-Net, you can use the weights of the original model as the initialization of the new one. Some training is still needed to finetune the weights to the new architecture, but much less than with random initialization. Once we implemented this, we only trained each network for 1 epoch in our testing. This helped with testing and debugging the network, since when using binarization for each layer in the network the linear regression had to be performed every iteration. This made the training 2 to 12 times slower, depending on the number of bits used for the binarization. This would have meant that without this initialization some networks would have needed to train for 12 days, which wouldn&#39;t be feasible for this project. . Bias . The ABC-Net paper makes no mention of using biases in their convolutions. However as biases were used by the LSID network, we did need to implement this. Since biases only account for a small part of the memory used and the computation needed, we decided to not binarize the biases in the network. . Normalization . As mentioned in section &quot;ABC-Net&quot;, one of the things that is needed to be able to binarize the activations is normalization. In ABC-Net this is done using batch normalization. However, this was not possible in our case since the GPU we used, did not have enough memory. When only binarizing the weights, batches of 8 could be used, which is already very small for batch normalization to work well. When we also binarized the activations even more memory was needed, since the binarized tensors still needed to be stored as 32-bit floats. This meant that we could only use a batch size of 1. Therefore we looked into 3 other types of normalization, namely, instance normalization, group normalization and layer normalization. Unfortunately, all of the normalization techniques hurt the performance of the model, with really low PSNR&#39;s even when not even binarizing the activations yet. We speculate that this might have to do with the fact that we use the weights of the trained LSID model as initialization. Adding normalization in can cause the activations to change significantly, which means that the weights also need to adapt. . Activation Binarization . Since we couldn&#39;t get normalization to work and the binarization of the activations in ABC-Net depend on this, we needed to find a new way to do this. In the end we chose to do it the same way as with the binarization of the weights. By picking the thresholds for binarizing equally distributed from minus the standard deviation to plus the standard deviation around the mean of the activation. After which the betas are calculated using linear regression again. This cannot lead to good efficiency during inference as the linear regression still has to be done at each layer every iteration. We thought this is an acceptable compromise, since, without the efficient operators, we couldn&#39;t show the actual efficiency benefits in practice anyway and this should still give comparable results in terms of accuracy. . Training details . To improve the reproducibility of the project, we will provide some details about our training process. We use the weight of the model trained by the authors as initialization. Then we train the model for 1 epoch using the 27975 image patches of size 512 by 512. The learning rate we used was $10e-4$. We tested multiple different combinations of $M$, $N$ (real-valued, $1$, $3$ and $5$). . Results . The results are shown in the table below and the visual representation can be seen by running the following code cell. When a cell in the table contains a &quot;x&quot;, that means the specific part has not been binarized and thus contains the full-precision values. Just as a reminder: $M$ are the amount of bits used for the weight approximation, $N$ is the amount of bits used for approximating the activations. The theoretical speedup has been calculated per setting as described earlier in this blog. . M N PSNR Theoretical speedup . Results by [1], in TensorFlow | x | x | 28.88 | 1x | . Results of [3], in PyTorch | x | x | 28.55 | 1x | . ABCLSID | 3 | x | 27.6 | 0.66x | . ABCLSID | 1 | x | 25.70 | 2x | . ABCLSID | 1 | 1 | 20.21 | 55.11x | . ABCLSID | 3 | 3 | 20.93 | 6.77x | . ABCLSID | 3 | 5 | ... | 4.08x | . ABCLSID | 5 | 3 | 21.19 | 4.08x | . ABCLSID | 5 | 5 | 21.86 | 2.46x | . from IPython.display import Image from google.colab import widgets from matplotlib import pylab tb = widgets.TabBar([&quot;M=1, N=x&quot; ,&quot;M=1, N=1&quot;, &quot;M=3, N=x&quot; ,&quot;M=3, N=3&quot; ,&quot;M=5, N=3&quot; ,&quot;M=5, N=5&quot;]) image_ids = [&quot;1XZuoIFNmI65Wuhnv4lEVDMP5YvVfy2fV&quot;,&quot;1Ypb9LUoJt5V44qu9zHXobbNwoa4NOZcn&quot;,&quot;1ihb4AvT8Jjj8g5N0zfLrss7-Bms0Vr5g&quot;,&quot;1niA76Jwfp6cIdWmnv70omRFBtAaut1Ub&quot;,&quot;1CK_rFLYvjPqkw2j4RIng8grU6ovAATWc&quot;,&quot;1BN66SlR4UVNOn09txj-9RQKpC-aKtVPX&quot; ] for t, i in enumerate(tb): display(Image(url=&quot;https://docs.google.com/u/0/uc?id=&quot;+image_ids[i], width = 1000, height = 700)) . Discussion . From the results section, one thing that is immediately clear, is when we start to binarize the activations, the performance of the network drops significantly. Even the network with real-valued activations and 1-bit weights performs much better than the network with 5-bit activations and 5-bit weights. We are not exactly sure about the reason for this. It could be that binarizing the activations simply causes too much loss of information for the network to function properly. For example in the images (refer to images with binary activations), you can see that a lot of the colour of the image is lost. Especially for $N=1$, there the image has almost become black and white. . One possible explanation for the loss in information might be that we noticed that for $M = N = 3$, the tensors of the estimated weights and activations only contained $4$ or $5$ unique values. Having a 3-bit accuracy, it should be possible to achieve 8 unique levels instead. When $M = N = 5$, it should be possible to output 32 different values, but instead, we found that the tensors only contained $5$ or $6$ unique values. . One explanation for this could be that the shifting of parameters to form $ boldsymbol{B}$ is not done optimally. Right now the shifts, which set the thresholds for binarization, are uniformly distributed over a range from minus the standard deviation to plus the standard deviation, which is the way it was described in the ABC-Net paper. However, since the distribution of weights often resembles a Gaussian distribution, it might be better to put the thresholds around the mean closer together and the thresholds further from the mean further apart, to better match the Gaussian distribution. Currently, in the interest of time for this project, we were unable to research further into this problem, but we expect that if more of the possible weights occur, that this will lead to a smaller approximation error, which in term helps with improving performance. . We deviated in one aspect from the original ABC-Net implementation, by implementing the binarization of the activations the same as for the weights. This was done because we could not get the ABCLSID network to work with normalization, which probably interfered with our initialization. Another technique that could be studied in the future that could make this work is taking the original LTSITD network and add normalization to it. This network could then be trained to match the performance of the original model. This new model could then be used to initialize the network when binarizing the activations and this means that when binarizing the activations the network does not also need to adapt to the normalization. . This also means that the network could use the learnable parameter beta, to possibly find better threshold values than the ones we used. This can make the approximations and thus also the performance of the network better. . Another reason for the loss in performance could be that there simply goes something wrong in our implementation of binarizing the activations. For example, it is possible that when binarizing the activations, the gradient is not calculated correctly anymore. This could cause the network to not properly learn and adapt to the new structure. We have seen, for instance, during some initial testing that the training and validation error would go up after the first epoch when training on a small subset of the training data. . It could also be that there is something wrong with the calculation of the backpropagation as described in ABC-Net. The definition in the paper, the one we use, uses the STE and is as follows: . $$ frac{ delta c}{ delta textbf{W}} = sum limits_{m=1}^M alpha_m frac{ delta c}{ delta textbf{B}_m}$$ . However, according to the author the following ABC-Net implementation cow8/ABC-Net-pytorch (https://github.com/cow8/ABC-Net-pytorch), this is not correct. They state that the correct formulation is: . $$ frac{ delta c}{ delta textbf{W}} = frac{ delta c}{ delta textbf{O}} cdot left( sum limits_{m=1}^M left( frac{ delta textbf{O}}{ delta alpha_m Conv(B_m, A)} cdot left( frac{ delta alpha_m}{ delta W} cdot Conv(B_m, A) + frac{ delta Conv(B_m, A)}{ delta W} cdot alpha_m right) right) right) $$ . We are not 100 % that this is indeed the case, especially since it is not from a peer-reviewed paper, but from a public Github repository that contains an implementation that does not yet work. However, it might be interesting to explore this further in the future. . References . [1] C. Chen, Q. Chen, J. Xu, and V. Koltun, “Learning to see in the dark”, CoRR, vol. abs/1805.01934,2018. [Online]. Available: http://arxiv.org/abs/1805.019341 . [2] X. Lin, C. Zhao, and W. Pan, “Towards accurate binary convolutional neural network”, CoRR, vol.abs/1711.11294, 2017. [Online]. Available: http://arxiv.org/abs/1711.112941 . [3] Cydonia, &quot;Learning to See in the Dark in PyTorch&quot;, 2018. [Online]. Available: https://github.com/cydonia999/Learning_to_See_in_the_Dark_PyTorch . [4] Mylio,2020.[Online].Available:https://focus.mylio.com/tech-today/how-many-photos-will-be-taken-in-2020 . [5] M. Rastegari, V. Ordonez, J. Redmon, and A. Farhadi, “Xnor-net:Imagenet classification using binary convolutional neural networks”, CoRR, vol. abs/1603.05279, 2016. [Online]. Available:http://arxiv.org/abs/1603.052791 . [6] E. Nurvitadhi, D. Sheffield, Jaewoong Sim, A. Mishra, G. Venkatesh, and D. Marr, “Accelerating bina-rized neural networks: Comparison of fpga, cpu, gpu, and asic,” in2016 International Conference onField-Programmable Technology (FPT), 2016, pp. 77–84. . Want to see more reproductions of this and other papers? Check https://reproduced-papers.firebaseapp.com/ . .",
            "url": "https://sfalkena.github.io/blogs/fastpages/jupyter/2020/07/01/LearningToEfficientlySeeInTheDark.html",
            "relUrl": "/fastpages/jupyter/2020/07/01/LearningToEfficientlySeeInTheDark.html",
            "date": " • Jul 1, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "Reproducing "Real-Time Single Image and Video Super-Resolution Using an Efficient Sub-Pixel Convolutional Neural Network"",
            "content": "By Luuk Balkenende, Sieger Falkena and Luc Kloosterman . This article describes a replication of Table 1 from the Real-time Single Image Super-Resolution [1] paper trained on the yang91 dataset with a validation on different datasets. The table below shows the original table from the paper and highlights the results which are attempted to reproduce. . . The reproduction is done using a Pytorch implementation which is written from scratch. Only the information given in the paper is used. Some hyperparameters are tuned as those are not mentioned in the paper. The code is developed on Google Colab and is compatible to run with a GPU. . Problem definition of the paper . Several models which are capable of upscaling single images already exist. [2] [3] [4] However, in these methods the super-resolution (SR) operation is performed in high resolution (HR) space. According to the writers of the paper: &#39;this is sub-optimal and adds computation complexity&#39;. The goal is to find a more efficient method to upscale images. More specifically, the goal is to make this process fast enough so that it can be applied real-time to video material. . Experiment setup as proposed by the authors . The authors of the paper propose a CNN architecture where the feature maps are extracted in low resolution (LR) space. Only at the very end of the network the resolution will be increased. The advantage of this network is two fold: The computational complexity of the whole model is low. Better and more complex SR operations are learned compared to other models. . The proposed CNN architecture, called ESPCN, is shown below. As can be seen, the ESPCN consists of three convolutional layers, two normal convolutional layers and one sub-pixel convolutional layer which aggregates the feature maps from LR space and performs the SR operation. This last layer is called the sub-pixel convolution layer. In the first layer the Y channel of a YCrCb LR image is taken as the input and is convolved with a kernel size of 5x5 to 64 different output channels. After this, two convolutional layers are used with a kernel size of 3x3 which reduces the number of channels to the square of the scaling factor. The last layer shuffles the pixels to obtain the final SR image. . . Implementation of the code . The actual code is implemented from scratch in this notebook, where only the information given in the paper is used. In this section, the steps which are taken in order to reproduce the desired results of the paper together with the python code are explained. Running the experiment on Google Colab The notebook is running remotely on the Google Colab platform. Therefore, to save and access the trained model, we needed to mount the Google drive. We used the following code snippet to set up a local drive on our computer. Furthermore, the packages needed to run the whole notebook are imported. . . Running the experiment on Google Colab . from torchvision import transforms from google.colab import drive from torch.utils import data from PIL import Image import matplotlib.pyplot as plt import PIL.Image as pil_image import torch.nn as nn import torchvision import numpy as np import torch import time import cv2 import os . If you want to run the notebook, please download the neccesary files from Github and make a copy from this notebook! . drive.mount(&#39;/content/gdrive&#39;) path =&#39;/content/gdrive/My Drive/deep_learning_group_7/Final&#39; os.chdir(path) . from IPython.display import HTML HTML(filename = path + &#39;/interactive_image.html&#39;) . ESPCN Architecture . Below, the ESPCN architecture as defined in the paper can be found. For the activation function a tanh is used, as the authors indicated this will lead to better results. The final sub-pixel convolution layer is divided into a normal convolutional layer (conv3) and a layer which performs the SR operation (upsample). Next to defining the model this cell checks the availability of a GPU and stores the model on the GPU if it is available. Note that for the implementation, an upscaling factor of 3 is used. . r = 3 #scaling factor class SuperResConvNet(nn.Module): def __init__(self): &#39;Initialize layers&#39; super(SuperResConvNet, self).__init__() self.conv1 = nn.Conv2d(1,64, kernel_size=5, stride=1, padding=2) self.conv2 = nn.Conv2d(64,32, kernel_size=3, stride=1, padding=1) self.conv3 = nn.Conv2d(32,1*r**2, kernel_size=3, stride=1, padding=1) self.upsample = nn.PixelShuffle(r) def forward(self, y): &#39;Define forward pass&#39; y = torch.tanh(self.conv1(y)) y = torch.tanh(self.conv2(y)) y = self.conv3(y) y = self.upsample(y) return y # Check for GPU availability if torch.cuda.is_available(): print(&quot;Using GPU&quot;) device = torch.device(&quot;cuda:0&quot; if torch.cuda.is_available() else &quot;cpu&quot;) # Define model and send to device ConvNet = SuperResConvNet() ConvNet.to(device) . Datasets and data processing . In order to train the above defined model, the images in the yang91 dataset are downsampled by a factor of 3 and saved on the drive. More about this operation can be found in the next section. . The model will not train on the whole images, but on small parts of the images, as explained in the paper. We refer to these small parts as patches in this reproduction. In order to reduce memory issues, it has been chosen to only save a list of names of the available patches per image, instead of the individual patches themselves. As can be seen in the code snippet below, the function getPatchList is searching for the available patches per image, while PatchList_get is saving the information of the former function into a list. During training time, the function createPatch is used to transform the entries of the list of available patches into real image patches. Finally, the bicubic upsampling function is used to load low resolution images and upsample them to high resolution images. Later, during visualisation, the luminance channel is substituted with the one upsampled by the model, while the Cr and Cb channels are kept. This makes that the images only trained on luminance can be displayed in color. Noticeably, multiple functions need to be called on the sets of images from different directories. For simplicity, all of these functions are accommodated in one class. . # Define directories slide_subfolders = [&#39;yang91/T91/&#39;, #trainingset &#39;x3.0/Set5/&#39;, &#39;x3.0/Set14/&#39;, # Testsets &#39;x3.0/BSD300/&#39;, &#39;x3.0/BSD500/&#39;, &#39;x3.0/SuperText136/&#39;] #width and height of patches x = 17 class Slide: &#39;Combines functions for loading and preparing images for training and testing&#39; def __init__(self, path, slide_subfolders, count): self.count = count self.dir = path + &#39;/CVPR2016_ESPCN_OurBenchMarkResult/Ours/&#39; + slide_subfolders self.namelist = self.deleteLRImage() if count == 0: self.patchlist = self.patchlist_get() def removePng(f): &#39;returns filename without png&#39; filename_parts = f[:-4] return filename_parts def getList(self): &#39;returns list of filenames&#39; return [Slide.removePng(f) for f in os.listdir(self.dir) if f.endswith(&quot;.png&quot;)] def deleteLRImage(self): &#39;deletes LR images from list if they are already made (which they are)&#39; name_list_2 = Slide.getList(self) name_list_1 = [x for x in name_list_2 if &quot;lr&quot; not in x ] name_list = [x for x in name_list_1 if &quot;lowRes&quot; not in x ] return name_list def getPatchList(self, img_name): &#39;returns patch list of one image&#39; #get filenames and load images filename = self.dir + img_name lr_img = cv2.cvtColor(cv2.imread(filename+&#39;_lr.png&#39;), cv2.COLOR_BGR2RGB) #parameters stride_lr = x-np.sum((5%2,3%2,3%2)) tot_img_d = int(lr_img.shape[0]/stride_lr), int(lr_img.shape[1]/stride_lr) #amount of image in height and width respectively tot_img = tot_img_d[0]*tot_img_d[1] #total amount of images #create list for current image patch_list = [] for i in range(tot_img_d[0]-1): for j in range(tot_img_d[1]-1): patch_list.append([img_name, i,j]) return patch_list def patchlist_get(self): &#39;create patch_list&#39; patch_list = [] for i in range(len(self.namelist)): patch_list.extend(self.getPatchList(self.namelist[i])) print(&#39;Found&#39;, len(patch_list), &#39;trainable patches out of&#39;, len(self.namelist), &#39;images.&#39;) return patch_list def createPatch(self, name): &#39;returns a patch&#39; img_name = name[0] patch_name = name[1], name[2] #get corresponding images filename = self.dir + img_name hr_img = cv2.cvtColor(cv2.imread(filename+&#39;.png&#39;), cv2.COLOR_BGR2YCrCb)[:,:,0] # only get Y channel from YCrCb lr_img = cv2.cvtColor(cv2.imread(filename+&#39;_lr.png&#39;), cv2.COLOR_BGR2YCR_CB)[:,:,0] #create hr patch stride_hr = (x-np.sum((5%2,3%2,3%2)))*r hr_patch = hr_img[stride_hr*patch_name[0]:(stride_hr*patch_name[0]+17*r),stride_hr*patch_name[1]:(stride_hr*patch_name[1]+17*r)] #create lr patch stride_lr = x-np.sum((5%2,3%2,3%2)) lr_patch = lr_img[stride_lr*patch_name[0]:(stride_lr*patch_name[0]+17),stride_lr*patch_name[1]:(stride_lr*patch_name[1]+17)] return lr_patch, hr_patch def bicubic_upsampling(self, img_n): &#39;Loading high and low resolution image and do a bicubic upsampling of the low resolution image&#39; #get corresponding images filename = self.dir + img_n hr_img = Image.open(filename + &#39;.png&#39;).convert(&#39;YCbCr&#39;) lr_img = Image.open(filename[:-9] + &#39;-lowRes.png&#39;).convert(&#39;YCbCr&#39;) #upsample bicubic = lr_img.resize(hr_img.size, Image.BICUBIC) return lr_img, bicubic, hr_img # return as pil images def getSlideList(slide_subfolders, path): &#39;Load Slide class for different directories&#39; slides = [] for i, slide in enumerate(slide_subfolders): slides.append(Slide(path, slide, i)) return slides slides = getSlideList(slide_subfolders, path) . PSNR calculation . PSNR is the performance metric to compare the real and the predicted high resolution images. The two functions below are used to calculate the mean squared error and the PSNR between two images. The PSNR calculation is already included here to make the code able to calculate the PSNR on validation images in between epochs during training. . def psnr_from_mselist(mse_list): &#39;Calculate PSNR&#39; mse = np.mean(mse_list) if mse == 0: return float(&#39;inf&#39;) else: return 20*np.log10(255/np.sqrt(mse)) def calc_mse(img_pred, img_hr): &#39;Calculate MSE&#39; return np.mean((img_pred*255 - img_hr*255)**2) . Dataset - Low Resolution image . In the paper, the writers are mentioning their way of downsampling the images: ‘To synthesize the low-resolution samples, we blur the high-resolution images using a Gaussian filter and sub-sample them by the upscaling factor.’ [1] However, there is no mention of the size of the Gaussian blur. In this reproduction, there is chosen to set this kernel size of this blur to (5,5) as can be seen in the code below. . ## ONLY RUN THIS CELL IF LOW RESOLUTION IMAGES ARE NOT PRESENT IN THE DIRECTORY def createLowRes(img_name, dir_91): &#39;saves low resolution image&#39; # Call HR image filename = dir_91 + img_name + &#39;.png&#39; hr_img = cv2.cvtColor(cv2.imread(filename), cv2.COLOR_BGR2RGB) # Blur HR image blur_img = cv2.GaussianBlur(hr_img,(5,5),0) # Apply subsampling lr_img = blur_img[::r,::r] # Save lr_img im = Image.fromarray(lr_img) im.save(dir_91 + img_name + &#39;_lr.png&#39;) for i in range(len(slides[0].namelist)): dir_91 = path + &#39;/CVPR2016_ESPCN_OurBenchMarkResult/Ours/&#39; + slide_subfolders[0] createLowRes(slides[0].namelist[i], dir_91) . . Training . Parameters . The code below defines the settings for the training of the ESPCN. As described in the paper the mean squared error criterion and the Adam optimizer will be used. Furthermore, multiple training parameters and the scheduler for dynamic learning rate reduction are defined. An initial learning rate of 0.01 is used and a final learning rate of 1e-4 as described by the paper. The choice of other hyperparameters will be justified later. . # Loss and optimizer criterion = nn.MSELoss() optimizer = torch.optim.Adam(ConvNet.parameters(), lr=0.01) # Parameters num_epoch = 5000 #Amount of epochs batch_size = 16 #Batch size train_val_ratio = 0.95 #Training validation ratio # Scheduler for dynamic reduction of the learning rate threshold_mu = 1e-6 # Treshold for decreasing learning rate. factor_value = 0.8 # Amount of decay per step, new lr = factor_value*lr. scheduler = torch.optim.lr_scheduler.ReduceLROnPlateau(optimizer, mode=&#39;min&#39;, factor=factor_value, patience=2, threshold=threshold_mu, min_lr=0.0001, eps=1e-08, verbose=True) . . Data loader . In order to use the yang91 dataset during training, it is loaded into a Dataset class. This class divides the list of available patches into different batches every epoch. Furthermore the returned patches, which as told before are created by the function createPatch, are transformed into Torch tensors. . The Dataset class is divided into two parts. One part contains 95% of the available training patches, while the second part contains the remaining 5%. The two parts are both loaded into a Dataloader. The Dataloader which has 95% of the training patches is called training_generator and is used to provide the model with patches during training of the model. The other Dataloader is called validation_generator and is called to validate the model during training time. . class DataGenerator(data.Dataset): &#39;Generates the dataset that is used for training the ESPCN&#39; def __init__(self, slides): self.slides = slides self.transform = torchvision.transforms.Compose([ torchvision.transforms.ToTensor()]) def __len__(self): &#39;Returns the amount of patches&#39; return len(self.slides.patchlist) def __getitem__(self, idx): &#39;Returns low and high resolution patches in the form of tensors&#39; lr_patch, hr_patch = self.slides.createPatch(self.slides.patchlist[idx]) # transform images to pytorch tensors lr_patch = self.transform(lr_patch) hr_patch = self.transform(hr_patch) return lr_patch, hr_patch # Put DataGenerator in DataLoader full_dataset = DataGenerator(slides[0]) # Split between training and validation set train_size = int(train_val_ratio * len(full_dataset)) validation_size = len(full_dataset) - train_size training_set, validation_set = torch.utils.data.random_split(full_dataset, [train_size, validation_size]) # Create training and validation data loaders training_generator = data.DataLoader(training_set, batch_size=batch_size, num_workers=batch_size, shuffle=&#39;True&#39;) validation_generator = data.DataLoader(validation_set, batch_size=1, num_workers=1, shuffle=&#39;False&#39;) . Training the model . The actual training of the model is done in the code below. Every epoch consists of two parts. In the first part (training), the model is trained and in the second part (validation) the model is validated. The algorithm will repeat these two parts until it has done the number of epochs defined above. During training low resolution patches are sent in batches to the GPU. On the GPU, the forward pass of the ESPCN network is executed. Next, the corresponding high resolution patches and the outputs after the forward pass are used to calculate the loss. During the backpropagation, the optimizer is used to find the gradient for every parameter. The parameters are updated correspondingly to that gradient. At last, the average loss of one epoch is stored in a list. During validation the same procedure as in training is followed, with the exception of not executing the backpropagation. Furthermore, the PSNR of the validation patches is calculated and stored. After the training, it will compute the training time. . # Initializing lists used for saving losses and PSNR loss_list = [] epoch_loss_list = [] val_loss_list = [] validation_psnr = [] # Start timer t0 = time.time() # Training loop for epoch in range(num_epoch): # Switch to training mode ConvNet.train() for i, (lr_patch, hr_patch) in enumerate(training_generator): # Transfer training data to active device lr_patch, hr_patch = lr_patch.to(device), hr_patch.to(device) # Run the forward pass outputs = ConvNet(lr_patch) loss = criterion(outputs, hr_patch) loss_list.append(loss.item()) # Backprop and perform Adam optimisation optimizer.zero_grad() loss.backward() optimizer.step() # Save loss every epoch epoch_loss = np.sum(loss_list)/len(training_generator) epoch_loss_list.append(epoch_loss) # Print epoch loss every 50 epochs if epoch % 50 == 0: print(&quot;Epoch&quot;, epoch, &quot;loss: {}&quot;.format(epoch_loss)) # Save model every 1000 epochs (in case Google Colab stops runtime) # if epoch % 1000 == 999: # model_name = &#39;final_&#39; + str(epoch+1) + &#39;_epochs&#39; # path_model = path + &#39;/saved_models/&#39; + model_name # torch.save(ConvNet.state_dict(), path_model) # print(&#39;Model saved as: &#39;, model_name) # Step to next step of lr-scheduler scheduler.step(epoch_loss) loss_list = [] # Enter validation mode ConvNet.eval() # Keep track of mse for every patch, to collectively calculate PSNR per epoch epoch_mse = [] with torch.no_grad(): for i, (lr_patch, hr_patch) in enumerate(validation_generator): # Transfer training data to active device (GPU) lr_patch, hr_patch = lr_patch.to(device), hr_patch.to(device) # Predict output img_pred = ConvNet(lr_patch) # Calculate validation loss loss = criterion(img_pred, hr_patch) loss_list.append(loss.item()) # Calculate mse for every sample img_pred = img_pred[0].cpu().numpy() hr_patch = hr_patch[0].cpu().numpy() epoch_mse.append(calc_mse(img_pred, hr_patch)) # Calculate validation psnr on the complete epoch from all individual MSE&#39;s val_psnr = psnr_from_mselist(np.array(epoch_mse)) validation_psnr.append(val_psnr) # Save validation loss every epoch val_loss = np.sum(loss_list)/len(validation_generator) val_loss_list.append(val_loss) loss_list = [] print(&#39;Training took {} seconds&#39;.format(time.time() - t0)) print(&#39;Seconds per epoch:&#39;,(time.time()-t0)/num_epoch) . Plotting of training results . The script below will plot the training and validation loss for each epoch and a separate plot for the validation PSNR per epoch. . # Show training and validation loss of current model in memory plt.figure(figsize=(8,8)) plt.subplot(2,1,1) plt.title(&#39;Loss per epoch&#39;) plt.plot(np.arange(num_epoch), epoch_loss_list, label=&#39;Training loss&#39;) plt.plot(np.arange(num_epoch), val_loss_list, label=&#39;Validation loss&#39;) plt.yscale(&quot;log&quot;) plt.legend() plt.subplot(2,1,2) plt.title(&#39;PSNR for validation data&#39;) plt.plot(np.arange(num_epoch), validation_psnr) plt.show() . Testing . Loading the trained model . The code below is used to load the parameters of previous trained models from the ‘saved_models’ directory. . # Load weight in earlier defined model model_name = &#39;final_test_5000_epochsweights&#39; path_model = path + &#39;/saved_models/&#39; + model_name ConvNet.load_state_dict(torch.load(path_model)) . Test image plot function . The function below is used to compare the predictions with the low and high resolution images. From left to right it shows the low resolution, the output of the neural network and the high resolution image respectively. . def generate_figure(lr_img, sr_img, hr_img): &#39;Show the low resolution, upscaled and high resolution image&#39; f = plt.figure(figsize=(8*3,8)) f.add_subplot(1, 3, 1) plt.imshow(transforms.ToPILImage(&#39;YCbCr&#39;)(lr_img[0]).convert(&#39;RGB&#39;)) f.add_subplot(1, 3, 2) plt.imshow(transforms.ToPILImage(&#39;YCbCr&#39;)(sr_img[0]).convert(&#39;RGB&#39;)) f.add_subplot(1, 3, 3) plt.imshow(transforms.ToPILImage(&#39;YCbCr&#39;)(hr_img[0]).convert(&#39;RGB&#39;)) . Data loader . The Dataloader in the next code snippet is the same as the used Dataloader for training. However, it deviates from the training Dataloader in two ways. Firstly, it loads images, instead of patches (during training). Secondly, it also loads bicubic upsampled low resolution images. In the next section, it will be explained why the bicubic upsampled images are needed. . class DataGenerator_test(data.Dataset): &#39;Generates the dataset used for testing&#39; def __init__(self, slides): self.slides = slides self.transform = torchvision.transforms.Compose([torchvision.transforms.ToTensor()]) def __len__(self): &#39;Returns the amount of test images&#39; return len(self.slides.namelist) def __getitem__(self, idx): &#39;Returns low, upsampled and high resolution testing images in the form of tensors&#39; lr_img, bicubic, hr_img = self.slides.bicubic_upsampling(self.slides.namelist[idx]) lr_img = self.transform(lr_img) hr_img = self.transform(hr_img) bicubic = self.transform(bicubic) return lr_img, bicubic, hr_img ## Put DataGenerator in DataLoader def DataGenerator(slides): &#39;Create dataloader for every test directory&#39; test_set = DataGenerator_test(slides) test_generator = data.DataLoader(test_set, batch_size=1, shuffle=False) return test_generator . Testing the model . Finally, the ESPCN can be tested on the different test data sets. In the code below Set5, Set14, BSD300, BSD500 and the Supertexture136 dataset are used to reproduce the results from the paper. . The low resolution images are fed to the ESPCN, which outputs only the predicted high resolution Y (luminance) channel of the input images. Next, the Y channels of the bicubic upsampled images are replaced by these predicted Y channels of the network. This last step is done to display a random sample of every test set. . In order to compare this reproduction with the paper, the PSNR of every test set is calculated. Also, the average time it takes to produce an upsampled image by this reproduction is determined. This is computed to get an intuition about the authors claim of real-time SR of videos. . import random as rnd rnd.seed(9) # Loop over test data sets for j in range(len(slides[1:])): # Load data test_generator = DataGenerator(slides[j+1]) show = rnd.randint(0,len(test_generator)) # Define lists outputs = [] mse_list = [] time_list = [] # Main testing loop for i, (lr_img, bicubic, hr_img) in enumerate(test_generator): with torch.no_grad(): # Only test on the Y (intensity channel) to_network = (lr_img[:,0,:,:]).unsqueeze(0) # Start timer start_time = time.time() # Run the forward pass outputs = ConvNet.cpu()(to_network) img_pred = outputs[0] # Substitute the Y channel from bicubic with the one outputted by the model bicubic[:,0,:,:] = img_pred #Stop timer elapsed_time = time.time() - start_time time_list.append(elapsed_time) # Calculate MSE mse = calc_mse(img_pred.numpy(), hr_img.numpy()[:,0,:,:]) mse_list.append(mse.item()) #Show one random image from every dataset if i == show: generate_figure(lr_img, bicubic, hr_img) # Printing the results print(slide_subfolders[j+1], &#39;: PSNR&#39;, psnr_from_mselist(mse_list), &#39;Average time&#39; ,np.mean(time_list)) . Hyperparameter tuning . As described above there are multiple uncertainties regarding the reproducibility of the paper. Therefore, hyperparameter tuning is conducted on multiple hyperparameters in order to match the results of the paper. The hyperparameters which will have been tuned are the batch size, the learning rate threshold μ, the learning rate decay factor, the learning rate patience and the ratio between the training and the validation set. All hyperparameters are tuned independently while keeping the other hyperparameters fixed during training sessions of 300 epochs. Results of the hyperparameter tuning can be seen in the separate notebook which can be found here. The default values of the hyperparameters have been set to: . Batch size: 16 | Learning rate threshold μ: 1e-4 | Learning rate decay factor: 0.5 | Learning rate patience: 2 | Training validation set ratio: 80/20 | . Batch size . Batch size is one of the hyperparameters not specified in the paper which can have an impact on the final results. Having a small batch size will increase the training speed and needs less memory but it will reduce the accuracy of gradient estimation. For optimization a batch size of 4, 8 ,16 and 32 is investigated. As it can be seen below a batch size of 16 will result in the highest performance during training. Furthermore, a strange behaviour is observed for a batch size of 4 (green line). At first, the loss decays normally, after which it suddenly explodes and decreases again. There needs to be done more research into why this is happening. The defined learning rate decay and/or Adam optimizer might be the cause of this behaviour. . . Learning rate threshold &#956; . The learning rate threshold μ is described as a threshold on the improvement of the cost function. If the improvement of the cost function is smaller than the learning threshold then the learning rate will be decreased. With a higher μ the learning rate will reach the final learning rate of 0.0001 earlier during training. In order to establish the μ which gives the best results a threshold of 1e-2, 1e-4, 1e-6, 1e-8 and 1e-10 is investigated. As can be seen, every threshold results in almost the same performance, with the exception of the largest threshold: 1e-2. The values 1e-6 and 1e-10 appear to give the best results, however the margin with the other values is small. Therefore, this slightly better result can be due to the randomness in the learning process (initialization of model, splitting training dataset into training and validation patches, batch generation). The experiment needs to be repeated to give a standard deviation to the curves, and thus a better answer to the question which learning rate needs to be used. . Learning rate decay factor . Whenever the learning rate threshold μ is reached the learning rate will decrease with a certain factor. This factor is described by the learning rate decay factor and is also not specified in the paper. In contrast to the learning rate threshold μ, a higher learning rate decay factor will result in the final learning rate being reached later during training. To find the learning rate decay which results in the highest performance the model is trained on a learning rate decay factor of 0.5, 0.6, 0.7, 0.8 and 0.9. As it can be seen below a learning rate decay factor of 0.8 will result in the highest performance during training. . . Learning rate patience . Another hyperparameter which is tunable is the learning rate patience. Whenever the learning rate threshold μ is exceeded, the model will delay the decreasing of the learning rate with a number of epochs. This delay is defined by the learning rate patience. For optimization a learning rate patience of 1, 2, 4, and 8 are investigated. As it can be seen below, a learning rate patience of 8 gives significantly lower performance compared to the others which are quite similar. . . Ratio between the training and the validation set . The final hyperparameter which is tuned is the ratio between the size of the training set and the size of the validation set. From the yang91 training set a small subset is subsampled to validate the performance during training. For optimization usage of 80%, 90% and 95% of the training set are investigated. As it can be seen below a training validation ratio of 95/5 will result in the best performances. This is as expected, as the model has now learned on more patches per epoch and will thus be able to perform better on patches of the same types of images. . Results . Chosen hyperparameters . After the hyperparameter tuning, there is chosen to set the hyperparameters to the following values for the final training run: . Batch size: 16 | Learning rate threshold μ: 1e-6 | Learning rate decay factor: 0.8 | Learning rate patience: 1 | Training validation set ratio: 95/5 | Number of epochs: 5000 | . Training results . In the figures below, one can see the PSNR of the validation data vs. the number of epochs and the training and validation loss vs number of epochs. It can be seen that the model is learning, also for a large number of epochs. However, the amount it learns is decreasing for an increasing amount of epochs. . . Test set results . The reproduced model has been evaluated on the 5 test datasets as described earlier. The results are shown in the table below. Values are in dB and represent the mean PSNR of that dataset. . Dataset: Set5 Set14 BSD300 BSD500 SuperTexture136 . Results by [1], using tanh | 32.55 | 29.08 | 28.26 | 28.34 | 26.42 | . Reproduced results | 24.15 | 24.10 | 25.29 | 25.16 | 24.40 | . Below you can see three images of a butterfly. The left image is the low resolution image, the middle image is the image produced by the model and the right the high resolution image. . . As can be clearly seen, the model is in general capable of upsampling the low resolution image to a high resolution image. However, when looking closely at some white spots on the butterfly’s wing, one can see black spots. Here, the model fails locally to produce a good image. These black spots will be discussed in the next section. . Again you can see three images below, this time from peppers (left: low resolution, middle: predicted high resolution, right: high resolution). . . Again, the prediction looks to be very similar to the high resolution image. However, there appear some white spots in black areas (right bottom of image). These white spots will also be discussed in the next section. . In order to question the claim of the writers of the papers that real-time SR of 1080p videos is possible with their model, we calculated the average time it takes to produce an image by our reproduction. The obtained values in seconds are shown in the table below. . Dataset: Set5 Set14 BSD300 BSD500 SuperTexture136 . Time per image[s] | 0.0158 | 0.0303 | 0.0199 | 0.0200 | 0.0114 | . A standard video has a frame rate of 27 FPS. [5] This means that the model needs to produce an image within (1/27) 0.0370s. As can be seen in the table, this is indeed the case. However, these images are not 1080p, but more close to 180p. However, we think that the table is an indication that the model should be able to do real-time SR of 1080p videos, as the above results are obtained on a CPU of google colab. Running the model on a GPU on a good pc nowadays will most likely produce 1080p images even faster. . Discussion . Here, the reproducibility of the paper will be discussed. First, let&#39;s discuss a couple of things that were unclear about the implementation: . Unclarities . The stopping criterion . In the paper, the authors define the stopping criterion as follows: The training stops after no improvement of the cost function is observed after 100 epochs. However, only this sentence can already be interpreted in two ways: Train for a minimum of 100 epochs and then stop when no improvement can be observed, or, train for a number of epochs, so that a window of 100 epochs falls within some threshold value. Moreover, the value of this threshold is not mentioned in the paper. As this would require another hyperparameter to tune, it has been chosen to train the network for a fixed number of epochs, so that the network trains within some time limit. No indication on the total number of epochs has been given in the paper, so it has been set to a value of 300 during most of the hyperparameter tuning. Within 300 epochs, the loss converges enough to see if a setting works well or not. For the final model, the amount of epochs was based on available time and has been chosen to be 5000 epochs . The learning rate . The paper mentions the following about the value of the learning rate: Initial learning rate is set to 0.01 and final learning rate is set to 0.0001 and updated gradually when the improvement of the cost function is smaller than a threshold µ. This has been implemented with the PyTorch method: ReduceLRonPlateau, which reduces the learning rate in a similar way as described in the paper. However, the value of µ has not been mentioned in the paper. During hyperparameter tuning, several values have been tried, leading to the conclusion that only large values of µ were not working very well. . The luminance channel . The paper states the following sentence: “For our final models, we use 50,000 randomly selected images from ImageNet [5] for the training. Following previous works, we only consider the luminance channel in YCbCr colour space in this section because humans are more sensitive to luminance changes” [6]. This sentence has been interpreted as that the model has been trained and evaluated on the luminance (Y) channel of the input images. This conclusion has been drawn by also looking at the model architecture where it seems that only one channel has been used as the input for the model. As the model also outputs the luminance channel, the choice has been made to also evaluate the model on the PSNR of two luminance images. . Discussion of our implementation: . The unclarities about the paper are not the only thing contributing to the fact that our results are different from the original paper. During the visualization of the test phase, it was noted that some of the output images contained white spots in dark areas and dark spots in light areas. We believe this is a great contributor to our apparently low PSNR. We have been trying to understand what causes this, but at the time of writing, have not succeeded in finding the cause. . Furthermore, we found some inconsistencies in the used test data. The high resolution images of one folder appear to be slightly different than the high resolution images of another folder, while this should in fact be exactly the same images. Therefore, it can be the case that we have used slightly altered test images in comparison with the paper’s test images, resulting in lower PSNR values. . To reproduce or not to reproduce? . The aim of this blogpost is to reproduce the results found in the “Real-Time Single Image and Video Super-Resolution Using an Efficient Sub-Pixel Convolutional Neural Network”. In order to do so, a pytorch implementation is written from scratch using only information from the paper itself. The paper presents a method for image super resolution which is fast enough so that it can be applied on real-time video material. This is done with a CNN architecture, consisting of three convolutional layers, where the feature maps are extracted on the luminance channel in low resolution space. After this, the resolution is increased only at the very end by an upsampling layer. . At the beginning of the project the paper was easy to read for us being no experts in the field of deep learning. Diving into the process of reproducing the paper we discovered that some hyperparameters for training were not specified in the paper. Also, we encountered some other uncertainties related to the stopping criterion and the luminance channel. Apart from the appearance of black and white spots we believe the visual results of our reproduction attempt are considerably accurate. . Although the performance of our reproduction is not as high as stated in the paper we believe that it is reproducible. As this was our first project in the field of deep learning we had no experience in finding the correct hyperparameters for training. For someone with a bit more experience we think the results of the paper should be easily reproducible. . References . [1] W. Shi et al., “Real-Time Single Image and Video Super-Resolution Using an Efficient Sub-Pixel Convolutional Neural Network,” 2016 IEEE Conference on Computer Vision and Pattern Recognition (CVPR). 2016, doi: 10.1109/cvpr.2016.207. . [2] Y. Chen and T. Pock, “Trainable Nonlinear Reaction Diffusion: A Flexible Framework for Fast and Effective Image Restoration,” IEEE Trans. Pattern Anal. Mach. Intell., vol. 39, no. 6, pp. 1256–1272, Jun. 2017. . [3] C. Dong, C. C. Loy, K. He, and X. Tang, “Image Super-Resolution Using Deep Convolutional Networks,” IEEE Transactions on Pattern Analysis and Machine Intelligence, vol. 38, no. 2. pp. 295–307, 2016, doi: 10.1109/tpami.2015.2439281. . [4] C. Osendorfer, H. Soyer, and P. van der Smagt, “Image Super-Resolution with Fast Approximate Convolutional Sparse Coding,” Neural Information Processing. pp. 250–257, 2014, doi: 10.1007/978-3-319-12643-2_31. . [5] R. Taylor, “A Beginners Guide to Frame Rates : Aframe.” [Online]. Available: https://aframe.com/blog/2013/07/a-beginners-guide-to-frame-rates/. [Accessed: 20-Apr-2020]. . [6] O. Russakovsky et al., “ImageNet Large Scale Visual Recognition Challenge,” International Journal of Computer Vision, vol. 115, no. 3. pp. 211–252, 2015, doi: 10.1007/s11263-015-0816-y. . [7] S. Schulter, C. Leistner, and H. Bischof, “Fast and accurate image upscaling with super-resolution forests,” 2015 IEEE Conference on Computer Vision and Pattern Recognition (CVPR). 2015, doi: 10.1109/cvpr.2015.7299003. . Want to see more reproductions of this and other papers? Check https://reproduced-papers.firebaseapp.com/ . .",
            "url": "https://sfalkena.github.io/blogs/fastpages/jupyter/2020/04/20/ESPCN_reproduction.html",
            "relUrl": "/fastpages/jupyter/2020/04/20/ESPCN_reproduction.html",
            "date": " • Apr 20, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "Hi! Glad that you want to know more about me! My name is Sieger Falkena, I am 24 years old and currently studying my Masters Embedded Systems. I made this website to show some of the work that I did during my studies. More about me will follow soon :) . Just so you know, this website is powered by fastpages 1. Take a look, its cool :) . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://sfalkena.github.io/blogs/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://sfalkena.github.io/blogs/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}